<div id="memory">
    Si bien podr칤amos simplemente procesar n칰meros y pasarlos directamente a una <b>funci&oacute;n</b> (como veremos con las <b>m칩nadas</b>), hacer esto provoca que nuestras operaciones y algoritmos se vuelvan mucho m치s complejos y lineales, alentando nuestro programa.<br/><br/>
    Por ello, es conveniente asignar y usar espacios de memoria, almacenando, leyendo y descartando datos como nos sea necesario. A estos espacios se les llama&nbsp;<u>variables</u>, y los datos que contienen son&nbsp;<i>valores</i>.<br/>Este proceso de apartar memoria se llama&nbsp;<i>inicializaci&oacute;n</i>.
    <br/><br/>
    A nivel de hardware, los valores se almacenan en RAM: esencialmente, la RAM es una tira muy larga, donde cada cent&iacute;metro puede leerse como 1 (osea, que contiene una carga el&eacute;ctrica) o 0 (que est치 descargado). Al convertir nuestro c&oacute;digo a un formato ejecutable, el compilador va asignarle un espacio de RAM a nuestra variable, y reemplazar&aacute; todas las instancias de su nombre con la distancia que tiene que viajar la m치quina dentro de su memoria para acceder a los datos &mdash; con su <i>direcci칩n</i>.<br>
    En caso que nuestra m치quina no tuviese espacio RAM suficiente, la m치quina simplemente ocupar&aacute; su almacenamiento f&iacute;sico para nuestros prop&oacute;sitos, destinando cierta parte para ello pero vastamente alentando nuestro programa.
    Claro, si intent&aacute;semos acceder directamente al valor sin m&aacute;s, la computadora simplemente nos regresar&iacute;a un largo hilo de 1s y 0s que, si bien algunas personas muy acostumbradas podr&iacute;an leerlo, no nos es pr&aacute;ctico.<br/><br/>
    La computadora tampoco sabe de que van &mdash;&nbsp;<span title="驕뢢잺游뱁">de hecho</span>, el que un compilador cheque si asignamos un valor del tipo asignado a una variable, aunque nos ayuda a evitar errores de&nbsp;<i>overflow</i>&nbsp;y de procesamiento por error de l&oacute;gica, es una capa de procesamiento extra que incluso expande el tiempo de compilaci&oacute;n; los lenguajes Assembly no incluyen tipos, porque el mismo c&oacute;digo binario tampoco los incluye.
    <br/><br/>
    Al ser una colecci&oacute;n de puertas l&oacute;gicas, la computadora por s&iacute; misma solo puede afectar los bits individuales y mandarlos de un lado a otro. Cuando ingresamos la instruccion de "imprimir," lo que pasa es que vamos a copiar ciertos bits a un registro del procesador (algunos que describen el tipo de instrucci&oacute;n a ejecutar, otros la instrucci&oacute;n espec&iacute;fica a la BIOS dentro de ese tipo, otros m&aacute;s que le dicen la longitud de lo que vamos a imprimir, y finalmente unos &uacute;ltimos que contienen el mensaje), quien luego los enviar치 a ciertas rutas que la parte del sistema que controla al hardware dicta. Ya este sistema (propiamente llamado&nbsp;<i>kernel</i>) o nuestro propio c&oacute;digo, por uso de bits indicadores de tipo en un espacio adyacente a nuestra variable o por inferencia basada en longitud declarada de la variable y cuantos bytes totales son usados, va a determinar que hacer con ellos, pero en t&eacute;rminos de operaciones, para el procesador todo valor se puede alterar de la misma manera &mdash; es en el espacio asignado en la RAM donde las cosas se pueden complicar por longitud del dato.
    <br/><br/>
    Adem&aacute;s de toooodo esto, los lenguajes se pueden clasificar en 3 tipos:
    <ul>
        <li><span><b><u>De manejo amplio:</u></b>: Incluye a C/C++, Go, Pascal y las Assemblies. Permiten al programador meterse a la memoria sin restricciones, pero pueden ser bastante peligrosos. En alg&uacute;n momento, Bjarne Stroustrup (creador de C++) dijo:<blockquote style="font-style: italic;">
            C te facilita tirarte un balazo en el pie. C++ lo hace m&aacute;s dif&iacute;cil, pero cuando lo haces, toda tu pierna explota.
        </blockquote>Esto es porque, adem&aacute;s de poder llenar la memoria de basura y dar control entero y directo de las variables (lo que puede hacer que alg&uacute;n par&aacute;metro quede en NULL y te tire todo el programa), puede hasta generar crasheos y malas se침ales que frien circuitos a pesar de tener las mejores intenciones.</span></li>
        <li><span><b><u>De manejo limitado</u></b>: Incluye a Java, Ruby, Swift y otros contados pocos. Permiten, hasta cierto punto, el uso de espacio en la RAM cuando es necesario, pero no sin restricciones.<br/>Estos y los siguientes contienen lo que se llama&nbsp;<i>recolector de basura</i>, que va librando espacio de RAM conforme las referencias a las variables dejan de aparecer.</span></li>
        <li><span><b><u>De manejo nulo</u></b>:&nbsp;JavaScript y muchos, muchos m&aacute;s. Programar sin acceso a memoria fuera de crear variables, pero con mucha m&aacute;s seguridad.</span></li>
    </ul>
</div>